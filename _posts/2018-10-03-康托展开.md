---
layout: post
title: 全排列康托展开
date: 2018-10-3
categories: blog
tags: [算法,全排列]
description: 将全排列和字典序排名一一映射
---

给定一个1\~n的排列A,求A在所有排列中的字典序排名(0是最小的).  
从左到右考虑(字典序的优先方向),第一个数是 $A_1$,那么对于任意排列B若 $B_1<A_1$,则B的字典序必然比A小.   
~~显然~~这样的B有 $(A_{1}-1)\times (n-1)!$个.  
这样推下去,对于任意 $A_i$若在 $A_{i+1\sim n}$中有 $k_i$个数比 $A_i$小,则可以找到 $k_i\times (n-i)!$个字典序比A小的排列B满足 $B_{1\sim i-1}=A_{1\sim i-1}$且 $B_i<A_i$.  
这样的B自然不会重复.  
于是排列A的字典需排名rank(A)就很容易发现了:  
$$rank(A)\;=\;\sum_{i=1}^{n}k_i\times (n-i)!$$  
$$k_i\;=\;\sum_{j=i}^{n}A_{j}<A_{i}$$  
可以 $O(n^2)$求出.  

那么如果已知一个rank(A),怎么反求出A呢?  

先把rank(A)转换为k数组.  
由$rank(A)\;=\;\sum_{i=1}^{n}k_i\times (n-i)!$这一式子可推导出k.
有了k数组,就可以从右到左先设$A_i=k_i$.  
由于多了个$k_i$可能会重复,所以要把已确定的$A_j=k_i$的$A_j$改成$k_i+1$.  
同样多了个$k_i+1$,还得把$A_j=k_i+1$的改成$k_i+2$...  
总的来说,把已确定的$A_j\geq k_i$改为$A_j=A_j+1$.  
可以 $O(n^2)$求出. 
