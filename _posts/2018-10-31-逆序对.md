---
layout: post
title: 逆序对
date: 2018-10-31
categories: blog
tags: [算法, 逆序对]
description: 求逆序对数量的一些算法
---

在数列a中,逆序对即是满足$i< j\;and\;a_i> a_j$的数对.  
许多情况下你推式子推着推着就推出个$\sum_{i=1}^n \sum_{j=i+1}^n a_i> a_j$,这就是逆序对的数量.  

- 暴力:  
朴素的求法自然是$O(n^2)$地枚举i,j统计,这里不再赘述.  
- 归并:  
前置技能: 归并排序.  
这应该是最主流的求逆序对的方法了.  
要求一个区间内的逆序对数,假设已经递归求出两个子区间的逆序对数,接下来要做的就是求一个在左区间,一个在右区间的逆序对数.  
考虑归并排序的过程,在两个指针比较大小时进行统计.  
设左右区间的当前比较指针(下标)为p1,p2,  
当找到第一个p2使$a_{p1}< a_{p2}$时,可知$\forall i\in [p1max+1, p2),\;a_{p1}> a_{p2}$.  
那么横跨两个子区间的以p1为左端点的逆序对就有p2-p1max-1个.  
对所有p1统计和即可.  
值得注意的是,p2>r(区间右端点)退出时,此时左区间未处理的数对答案都有r-p1max的贡献因为此时左区间剩下的数都比右区间所有数大.  
复杂度$O(n*log_2n)$.  
- 线段树/树状数组:  
前置技能: 线段树(或树状数组).  
以线段树为例.  
用线段树维护区间内有效数的个数.  
之所以是有效的数,是因为要从小到大删数.  
如果一个数$a_i$是最小的,那么以其为右端点的逆序对就是1至i-1的数的个数.  
接下来呢?  
在线段树中删掉最小的数(单点修改-1),那么第二小的数$a_j$在此时就是最小的数,同样有1至j-1的数的个数(区间查询)的贡献.  
以此类推从小到大一个个删数即可.  
复杂度$O(n*log_2n)$.  
