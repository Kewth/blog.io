---
layout: post
title: 杜教筛
date: 2018-09-05
categories: blog
tags: [算法,杜教筛]
description: 转载
---

[原文地址]("https://www.cnblogs.com/peng-ym/p/9446555.html")
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
<title>杜教筛 - pengym - 博客园</title>
<meta property="og:description" content="杜教筛 ~~（似乎有很多人在催我的杜教筛呢......）~~ 前言 话说，我是不是在自己的 "莫比乌斯反演" 中挖了许多杜教筛的坑啊...... 本文完整的总结介绍杜教筛，也算是将莫比乌斯反演中的坑全" />
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=D7Le-lOZiZVAXQkZQuNwdTWqjabXaVBE_2YAWzY_YZs1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/SimpleMemory/bundle-SimpleMemory.css?v=EanP3quXYv9G0oFCmz4BNBHvmK7M_Si1iD1EpUHL_441"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/365792.css?v=5ftNH%2fV0Fm4Iccdkymons86Yq4M%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/SimpleMemory/bundle-SimpleMemory-mobile.css?v=XGOE8_i3XCsAIQHcgl5c_8VAMMKRkj0W3Eckyc8qbso1"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/peng-ym/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/peng-ym/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/peng-ym/wlwmanifest.xml"/>
<script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
<script type="text/javascript">var currentBlogApp = 'peng-ym', cb_enable_mathjax=true;var isLogined=false;</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'blogpost-body', processEscapes: true },
        TeX: { 
            equationNumbers: { autoNumber: ['AMS'], useLabelIds: true }, extensions: ['extpfeil.js'] },
            'HTML-CSS': { linebreaks: { automatic: true } },
            SVG: { linebreaks: { automatic: true } }
        });
    </script><script src="//mathjax.cnblogs.com/2_7_2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/bundles/blog-common.js?v=yRkjgN2sBQkB4hX-wirHxPomeBT9sB5dawr6ob7KIvg1" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
<!-- 背景动画 -->
<canvas id="c_n9" width="1920" height="990" style="position: fixed; top: 0px; left: 0px; z-index: -1; opacity: 0.5;"></canvas>
<script src="https://files.cnblogs.com/files/jingmoxukong/canvas-nest.min.js"></script>
 <script type="text/x-mathjax-config">
   MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
 </script>
 <script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
 </script>
<!--PageBeginHtml Block End-->

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/peng-ym/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/peng-ym/">peng-ym</a></h1>
<h2>宁可艰难爬起，不愿平庸路过</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/peng-ym/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/pengym">联系</a></li>
<li>
<!----></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 16&nbsp; </span>
<span id="stats_article_count">文章 - 0&nbsp; </span>
<span id="stats-comment_count">评论 - 24</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/peng-ym/p/9446555.html">杜教筛</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"><h2 id="杜教筛">杜教筛</h2>
<p><del>（似乎有很多人在催我的杜教筛呢......）</del></p>
<hr />
<h2 id="前言">前言</h2>
<ul>
<li>话说，我是不是在自己的<a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演</a>中挖了许多杜教筛的坑啊......</li>
<li>本文完整的总结介绍杜教筛，也算是将莫比乌斯反演中的坑全部填满吧！</li>
<li>真诚地希望来阅读这篇学习笔记的每一个人，仔仔细细的看完每一段。</li>
<li>我相信，只要认真的看完整篇文章并跟着一起思考的读者，一定能够有所收获！</li>
<li>如果您之前不会杜教筛，那么我希望这篇文章能够作为您学习杜教筛路上的有力援助，帮助您真正的了解与掌握杜教筛！</li>
<li>如果您之前早已熟知杜教筛或只有些模糊的印象，相信您一定也能有所收获！</li>
<li>(PS：本文较长，请耐心阅读 ovo)</li>
</ul>
<hr />
<h2 id="在oi中的意义">在OI中的意义</h2>
<ul>
<li>其实，对于一般的数论题，线性筛已经非常的优秀了。</li>
<li>但是就是有那些<span class="math inline">\(duliu\)</span>出题人，硬是要把数据出到<span class="math inline">\(1e10\)</span>之类的，就看你会不会杜教筛，min_25筛，洲阁筛等各种神奇的筛法。<del>(PS:后面这两个筛法我是真的不会了QAQ)</del></li>
<li>要是不会，那就要少十分左右！</li>
<li>所以，专门用杜教筛来推式子的题目很少，一般都是用杜教筛优化线性筛，弄到最后的那些分。</li>
<li>不过，杜教筛的思想对于推式子是很有帮助的。（它那种递归求解的形式，以及复杂度<span class="math inline">\(O(n^\frac{2}{3})\)</span> ）</li>
<li>因此，学会杜教筛也是一件挺好的事情！</li>
</ul>
<hr />
<h2 id="前置技能">前置技能</h2>
<ul>
<li>杜教筛的前置技能挺多的......</li>
</ul>
<h3 id="各种函数">各种函数</h3>
<h4 id="概念">概念</h4>
<ul>
<li>首先，我们需要知道有一个东西叫做<strong>数论函数</strong></li>
<li>数论函数有很多种，但是我们身为<strong>Oier</strong>，并不需要知道它的具体的定义，具体的分类。</li>
<li>我们只需要知道，我们在<strong>OI</strong>中的数论中所用到的各种函数<span class="math inline">\(\mu,\varphi\)</span>等都是数论函数。(后面会将常见的都列举出来，当然不只这两种)。</li>
<li>当你了解<strong>数论函数</strong>后，你就需要知道有一类函数叫做<strong>积性函数</strong>。</li>
<li>还是同样的话语，我们平常所惯用的数论函数都是积性函数！</li>
<li>不过，对于积性函数的定义还是有必要了解一下。(毕竟有些函数看上去不常见，其实可能就是积性函数！)</li>
<li>积性函数定义：如果已知一个函数为数论函数，且<span class="math inline">\(f(1)=1\)</span>，并且满足以下条件，若对于任意的两个互质的正整数<span class="math inline">\(p,q\)</span>都满足<span class="math inline">\(f(p\cdot q)=f(p)\cdot f(q)\)</span>，那么则称这个函数为<strong>积性函数</strong>。</li>
<li>特殊的，如果当对于任意的正整数<span class="math inline">\(p,q\)</span>(即不一定互质)，也满足以上这个式子，则称这个函数为<strong>完全积性函数</strong>。</li>
<li>而我们的<strong>杜教筛</strong>，则是用来筛积性函数前缀和的神奇筛法！！！</li>
<li>说了这么多概念性的东西，不如来点实质性的！</li>
</ul>
<h4 id="常见积性函数">常见积性函数</h4>
<ol>
<li><span class="math inline">\(\mu(n)\)</span>——莫比乌斯函数。关于这个函数，我在<a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演</a>中说的挺清楚的了(233)，(PS：不过我将会在下文中，从另一种角度介绍它的性质。也算是把坑给填完吧)</li>
<li><span class="math inline">\(\varphi(n)\)</span>——欧拉函数。表示不大于<span class="math inline">\(n\)</span>且与<span class="math inline">\(n\)</span>互质的正整数个数，十分常见的数论函数。用数学式子表示即：<span class="math inline">\(\varphi(n)=\sum_{i=1}^{n}[(n,i)=1]\)</span> (PS:<span class="math inline">\((n,i)\)</span>表示<span class="math inline">\(gcd(n,i)\)</span>)</li>
<li><span class="math inline">\(d(n)\)</span>——约数个数。表示<span class="math inline">\(n\)</span>的约数的个数。用式子表示为：<span class="math inline">\(d(n)=\sum_{d|n}1\)</span>，也可以写作：<span class="math inline">\(d(n)=\sum_{d=1}^{n}[d|n]\)</span> （其实没什么太大区别啦！）</li>
<li><span class="math inline">\(\sigma(n)\)</span>——约数和函数。 即<span class="math inline">\(n\)</span>的各个约数之和。表示为：<span class="math inline">\(\sigma(n)=\sum_{d|n}d=\sum_{d=1}^{n}[d|n]\cdot d\)</span></li>
</ol>
<p>(PS：接下来列举的是完全积性函数)<br />
(PS：代表字母可能会与他人的略有不同，似乎在数学中没有统一的字母)</p>
<ol>
<li><span class="math inline">\(\epsilon(n)\)</span>——元函数。似乎也有人把它叫作<span class="math inline">\(e(n)\)</span>？其实无所谓啦~~我们只需要知道<span class="math inline">\(\epsilon(n)=[n=1]\)</span>。(看到这个是不是有种莫名的熟悉感呢？到了下文中，就会发现这种熟悉感是从哪来的啦！)</li>
<li><span class="math inline">\(I(n)\)</span>——恒等函数。所谓恒等就是这个函数的值恒为<span class="math inline">\(1\)</span>。</li>
<li><span class="math inline">\(id(n)\)</span>——单位函数。<span class="math inline">\(id(n)=n\)</span>。</li>
</ol>
<p>(当第一次看到这些完全积性函数的时候，是不是有人感觉这些完全积性函数毫无用处，都是一些简单的式子，只不过用符号表示了呢？在下一个前置技能——狄利克雷卷积中，你应该就会改变自己<span class="math inline">\(naive\)</span>的想法啦~)</p>
<h3 id="狄利克雷卷积">狄利克雷卷积 (<span class="math inline">\(*\)</span>)</h3>
<h4 id="基本知识">基本知识</h4>
<ul>
<li>听名字，似乎是一个很高深的东西。</li>
<li>其实，若是不理睬这个名字，只是把它当作一个新定义的符号，你应该就会发现，狄利克雷卷积也不是那样的难理解。</li>
<li>定义：两个数论函数<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>的卷积为<span class="math inline">\((f*g)(n)=\sum_{d|n}f(d) \cdot g(\frac{n}{d})\)</span>。前面的括号代表将<span class="math inline">\(f\)</span>卷<span class="math inline">\(g\)</span>，后面的括号代表范围。(PS：后面的括号一般可以省略不写，默认为<span class="math inline">\(n\)</span>)</li>
<li>很显然，狄利克雷卷积满足以下运算规律：</li>
</ul>
<ol>
<li>交换律(<span class="math inline">\(f*g=g*f\)</span>)；</li>
<li>结合律(<span class="math inline">\((f*g)*h=f*(g*h)\)</span>)；</li>
<li>分配律(<span class="math inline">\((f+g)*h=f*h+g*h\)</span>)；</li>
</ol>
<ul>
<li>在记忆方面，可以类比为乘法的运算法则，其实上面这几条运算规律是可以证明的！</li>
<li>举个例子，交换律。我们看狄利克雷卷积的式子，实质上就是<span class="math inline">\(n\)</span>的每一个约数带入<span class="math inline">\(f\)</span>中的值，乘上与之对应的约数在<span class="math inline">\(g\)</span>中的值。</li>
<li>显然，当交换<span class="math inline">\(f\)</span>和<span class="math inline">\(g\)</span>时，仅仅时枚举约数的顺序发生了改变，而每一个约数对答案的贡献是不会有改变的。因此存在交换律！</li>
<li>在大致了解了狄利克雷卷积的运算法则后，我们就需要提到上面所说的积性函数啦！</li>
<li>首先，元函数 <span class="math inline">\(\epsilon\)</span>。所谓元函数，指的就是在狄利克雷卷积中充当单位元的作用，单位元即满足：<span class="math inline">\(f*\epsilon=f\)</span>。不要小看这个元函数，当元函数配合上结合律时就可以用来证明一些结论啦~</li>
<li>除了元函数之外，我们最为常见的则是<span class="math inline">\(\mu,\varphi\)</span>之类的的函数，因此我们需要十分熟练它们与一些常见的完全积性函数的卷积，以及性质。</li>
</ul>
<p><strong>(PS：特别要记住一点：积性函数有一个特别重要的性质，那就是（积性函数<span class="math inline">\(*\)</span>积性函数）仍然为积性函数！！！这个性质可以用来判断能否被杜教筛！)</strong></p>
<h4 id="莫比乌斯函数mu">莫比乌斯函数<span class="math inline">\(\mu\)</span></h4>
<ul>
<li><span class="math inline">\(\mu\)</span>。在<a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演</a>中，我们曾了解过一个与<span class="math inline">\(\mu\)</span>有关的性质：<span class="math inline">\(\sum_{d|n}\mu(d)=[n=1]\)</span></li>
<li>我们将这个性质表示成狄利克雷卷积的形式即：<span class="math inline">\(\mu*I=\epsilon\)</span>。这在狄利克雷卷积中是一个很常用的恒等式。当然，有了它，我们也能够证明出莫比乌斯反演啦！</li>
<li>开始填坑，证明莫比乌斯反演：<br />
已知：<br />
<span class="math display">\[F(n)=\sum_{d|n}f(d)\]</span><br />
用狄利克雷卷积的形式表示这个式子即：<span class="math inline">\(F=f*I\)</span><br />
利用狄利克雷卷积将<span class="math inline">\(F\)</span>卷上<span class="math inline">\(\mu\)</span>，得到：<br />
<span class="math display">\[F*\mu=f*I*\mu\]</span><br />
由于狄利克雷卷积具有结合律与交换律，因此原式可化为：<br />
<span class="math display">\[\to f*(I*\mu)=f*\epsilon=f\]</span><br />
即：<span class="math inline">\(f=F*\mu\)</span>。代入后即可证明莫比乌斯反演：<span class="math inline">\(f(n)=\sum_{d|n}\mu(d)\cdot F(\frac{n}{d})\)</span><br />
同理，自然也可以得到莫比乌斯反演的另一种形式：<span class="math inline">\(f(n)=\sum_{n|d}\mu(\frac{d}{n})\cdot F(d)\)</span><br />
(总算填完一个大坑......)</li>
</ul>
<h4 id="欧拉函数-varphi">欧拉函数 <span class="math inline">\(\varphi\)</span></h4>
<ul>
<li><span class="math inline">\(\varphi\)</span>。欧拉函数有一个很著名的性质：<span class="math inline">\(\sum_{d|n}\varphi(d)=n\)</span>。</li>
<li>与以上方法类似，我们将它表示成狄利克雷卷积的形式：<span class="math inline">\(\varphi*I=id\)</span>。</li>
<li>这时候，看到这个式子我们会有一个大胆的想法，既然在这个欧拉函数与莫比乌斯函数的式子中都有<span class="math inline">\(I\)</span>，那么我们不如将这个式子的两边同时卷上一个<span class="math inline">\(\mu\)</span>。</li>
<li>于是，我就可以开始填第二个坑了——欧拉函数与莫比乌斯函数的关系。<br />
<span class="math display">\[\varphi*I=id \\\to \varphi*I*\mu=id*\mu \\\to \varphi*\epsilon=id*\mu\]</span><br />
即：<span class="math inline">\(\varphi=id*\mu \to \varphi(n)=\sum_{d|n}\mu(d)\cdot \frac{n}{d}\)</span></li>
<li>我们把这个式子的两边同时除以<span class="math inline">\(n\)</span>，则可以推出这个巧妙的式子：<br />
<span class="math display">\[\frac{\varphi(n)}{n}=\sum_{d|n}\frac{\mu(d)}{d}\]</span><br />
（至此，我终于把莫比乌斯反演中的坑填完啦~~23333）<br />
（有关杜教筛的前置技能也说的差不多啦，终于可以步入正题啦！）</li>
</ul>
<hr />
<h2 id="步入正题杜教筛">步入正题——杜教筛</h2>
<ul>
<li>说了这么久，终于可以开始讲杜教筛啦！（是不是有一种莫名的兴奋呢？）</li>
<li>首先，我们应该弄清楚一个问题：杜教筛到底是用来干什么的？</li>
<li>杜教筛是以低于线性的时间复杂度来计算积性函数的前缀和的神奇筛法！</li>
<li>即我们需要计算的式子为：<span class="math inline">\(\sum_{i=1}^{n}f(i)\)</span> (<span class="math inline">\(f(i)\)</span>为积性函数)</li>
<li>PS：接下来要讲解的是杜教筛的套路式，如果不懂为什么要这样做，也没有关系。只需要明白它是怎么推过来的就行了。实在看不懂就记个结论吧......</li>
<li>推式子时间到！</li>
<li>为了解决这个问题，我们构造两个积性函数<span class="math inline">\(h\)</span>和<span class="math inline">\(g\)</span>。使得<span class="math inline">\(h=f*g\)</span></li>
<li>现在我们开始求<span class="math inline">\(\sum_{i=1}^{n}h(i)\)</span>。</li>
<li>记<span class="math inline">\(S(n)=\sum_{i=1}^{n}f(i)\)</span>。<br />
<span class="math display">\[\sum_{i=1}^{n}h(i)=\sum_{i=1}^{n}\sum_{d|i}g(d)\cdot f(\frac{i}{d})\\\to =\sum_{d=1}^{n}g(d)\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f({i})\]</span><br />
<span class="math display">\[\to \sum_{i=1}^{n}h(i)=\sum_{d=1}^{n}g(d)\cdot S(\lfloor\frac{n}{d}\rfloor)\]</span><br />
接着，我们将右边式子的第一项给提出来，可以得到：<br />
<span class="math display">\[ \sum_{i=1}^{n}h(i)=g(1)\cdot S(n)+\sum_{d=2}^{n}g(d)\cdot S(\lfloor\frac{n}{d}\rfloor)\]</span><br />
<span class="math display">\[\to g(1)S(n)=\sum_{i=1}^{n}h(i)-\sum_{d=2}^{n}g(d)\cdot S(\lfloor\frac{n}{d}\rfloor)\]</span><br />
其中的<span class="math inline">\(h(i)=(f*g)(i)\)</span>;</li>
<li>这就是杜教筛的惯用套路式。经各种分析，只要当你的<span class="math inline">\(h(i)\)</span>的前缀和很好求，能在较短的时间内求出，那么当我们对后面的式子进行整除分块时，求<span class="math inline">\(S(n)\)</span>的复杂度为<span class="math inline">\(O(n^{\frac{2}{3}})\)</span></li>
<li>当我们知道了这个套路式后，可能会思考，我们应该如何选择这个<span class="math inline">\(g\)</span>与<span class="math inline">\(h\)</span>呢？</li>
<li>对于这个疑问，我没有太好的回答。只能说，依靠平时对于狄利克雷卷积中的各种式子的熟悉，以及仔细观察式子的能力啦！（当然我下面也会介绍一种小方法啦~~OVO）</li>
<li>知道了这个套路式总要练练手吧！</li>
</ul>
<h3 id="应用">应用</h3>
<p>(PS：以下例子中，假设线性筛均跑不过)</p>
<p>一：求<span class="math inline">\(S(n)=\sum_{i=1}^{n}\mu(i)\)</span>；</p>
<ul>
<li>根据那个套路式：<span class="math inline">\(g(1)S(n)=\sum_{i=1}^{n}(f*g)(i)-\sum_{d=2}^{n}g(d)\cdot S(\lfloor\frac{n}{d}\rfloor)\)</span>，我们只需要找一个积性函数<span class="math inline">\(g\)</span>使得这个函数与<span class="math inline">\(\mu\)</span>的卷积的前缀和容易求。如果你认真的看了上文，应该就可以很轻松的想到一个积性函数<span class="math inline">\(I\)</span>。</li>
<li>我们知道<span class="math inline">\(\mu*I=\epsilon\)</span>，很显然，单位元的前缀和非常好求，就是<span class="math inline">\(1\)</span>，并且<span class="math inline">\(I\)</span>十分方便整除分块。所以我们把这个积性函数带入上述式子中可以得到：<br />
<span class="math display">\[S(n)=1-\sum_{d=2}^{n}S(\lfloor\frac{n}{d}\rfloor)\]</span><br />
因此，我们就学会了杜教筛莫比乌斯函数的前缀和啦！</li>
</ul>
<p>二：求<span class="math inline">\(S(n)=\sum_{i=1}^{n}\varphi(i)\)</span></p>
<ul>
<li>与求莫比乌斯函数的思路类似。</li>
<li>我们在脑海中找到一个与欧拉函数有关的卷积式子：<span class="math inline">\(\varphi*I=id\)</span></li>
<li>我们可以发现，在筛欧拉函数前缀和所选择的积性函数<span class="math inline">\(g\)</span>同样也是<span class="math inline">\(I\)</span>哟！代入得：<br />
<span class="math display">\[S(n)=\sum_{i=1}^{n}i-\sum_{d=2}^{n}S(\lfloor\frac{n}{d}\rfloor)\]</span><br />
前面那个式子可以利用等差数列求和公式<span class="math inline">\(O(1)\)</span>的计算出结果，后面同样利用整除分块。<br />
所以，我们又学会了如何筛欧拉函数的前缀和啦！</li>
</ul>
<p>三：求<span class="math inline">\(S(n)=\sum_{i=1}^{n}i\cdot \varphi(i)\)</span></p>
<ul>
<li>这个式子是不是无法一眼看出需要配什么积性函数了呢？</li>
<li>我们考虑狄利克雷卷积的形式：<span class="math inline">\(\sum_{d|n}(d\cdot\varphi(d))\cdot g(\frac{n}{d})\)</span></li>
<li>我们看前面这个<span class="math inline">\(d\)</span>不太爽，考虑后面配出一个积性函数使得这个<span class="math inline">\(d\)</span>能够被约掉。因此，我们尝试将<span class="math inline">\(g\)</span>配成<span class="math inline">\(id\)</span>。这样就可以把<span class="math inline">\(d\)</span>给弄没！代入得：<br />
<span class="math display">\[\sum_{d|n}(d\cdot\varphi(d))\cdot \frac{n}{d}=\sum_{d|n}n\cdot\varphi(d)\\\to=n\sum_{d|n}\varphi(d)=n^2\]</span><br />
我们惊喜的发现，似乎配对了！！！<br />
得：<br />
<span class="math display">\[S(n)=\sum_{i=1}^{n}i^2-\sum_{d=2}^{n}d\cdot S(\lfloor\frac{n}{d}\rfloor)\]</span><br />
对于这个式子，我们前面可以利用平方和的公式<span class="math inline">\(O(1)\)</span>算出结果，后面的式子利用等差数列求和公式进行整除分块。<br />
因此，我们可以通过以上的思路求得这个看似无法筛的积性函数的前缀和！</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<ul>
<li>至于在信息学中的代码实现，我给出一个大概的思路：我们首先先线筛出数据范围根号左右的积性函数的前缀和。再递归的实现杜教筛。</li>
<li>特别要注意的是，杜教筛筛出的前缀和一定要存下来！！！</li>
<li>如果你比较的勤劳，那就去手写hash，如果你想偷懒，那就最好用stl中的unordered_map，最好不要用map，平白无故多个log的复杂度，何必呢......</li>
<li>还有一点，一定要记得取模！！！以及，判断要不要开long long，搞不好你TLE就是因为取模去多了，或者long long开多啦！</li>
<li>有评论区的大佬提醒我，说这份代码被卡了，我调了一下前面线筛的范围，有一定的加速，最后发现，果然是开long long的锅，现在已经将代码改正，是没有问题的啦！</li>
<li>在这里我就粘一下自己杜教筛<span class="math inline">\(\mu\)</span>和<span class="math inline">\(\varphi\)</span>的板子吧。这种东西最好自己手打一遍，不然你一没注意，常数一大，就很麻烦啦！（反正我写这个东西，常数巨大）</li>
<li>因此，代码仅供参考！<a href="https://www.luogu.org/problemnew/show/P4213">luoguP4213杜教筛模板</a></li>
</ul>
<pre class="cpp"><code>#include&lt;bits/stdc++.h&gt;
#include&lt;tr1/unordered_map&gt;
#define N 5001000
using namespace std;
template&lt;typename T&gt;inline void read(T &amp;x)
{
    x=0;
    static int p;p=1;
    static char c;c=getchar();
    while(!isdigit(c)){if(c==&#39;-&#39;)p=-1;c=getchar();}
    while(isdigit(c)) {x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c-48);c=getchar();}
    x*=p;
}
bool vis[N];
int mu[N],sum1[N];
long long phi[N],sum2[N];
int cnt,prim[N];
int e,e1;
tr1::unordered_map&lt;long long,long long&gt;w1;
tr1::unordered_map&lt;int,int&gt;w;
void get(int maxn)
{
    phi[1]=mu[1]=1;
    for(int i=2;i&lt;=maxn;i++)
    {
        if(!vis[i])
        {
            prim[++cnt]=i;
            mu[i]=-1;phi[i]=i-1;
        }
        for(int j=1;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=maxn;j++)
        {
            vis[i*prim[j]]=1;
            if(i%prim[j]==0)
            {
                phi[i*prim[j]]=phi[i]*prim[j];
                break;
            }
            else mu[i*prim[j]]=-mu[i],phi[i*prim[j]]=phi[i]*(prim[j]-1);
        }
    }
    for(int i=1;i&lt;=maxn;i++)sum1[i]=sum1[i-1]+mu[i],sum2[i]=sum2[i-1]+phi[i];
}
int djsmu(int x)
{
    if(x&lt;=5000000)return sum1[x];
    if(w[x])return w[x];
    int ans=1;
    for(int l=2,r;l&lt;=x;l=r+1)
    {
        r=x/(x/l);
        ans-=(r-l+1)*djsmu(x/l);
    }
    return w[x]=ans;
}
long long djsphi(long long x)
{
    if(x&lt;=5000000)return sum2[x];
    if(w1[x])return w1[x];
    long long ans=x*(x+1)/2;
    for(long long l=2,r;l&lt;=x;l=r+1)
    {
        r=x/(x/l);
        ans-=(r-l+1)*djsphi(x/l);
    }
    return w1[x]=ans;
}
int main()
{
    int t;
    read(t);
    get(5000000);
    while(t--)
    {
        static int n;
        read(n);
        printf(&quot;%lld %d\n&quot;,djsphi(n),djsmu(n));
    }
    return 0;
}</code></pre>
<hr />
<h2 id="总结">总结</h2>
<ul>
<li>当然，杜教筛还能够筛许多东西，如：<span class="math inline">\(\sum_{i=1}^{n}i^2\cdot\mu(i)\)</span>之类的一系列积性函数，在这里就不一一列举啦。</li>
<li>其实，一般来说筛的就是那些常用的积性函数。</li>
<li>如果实在碰到类似与上面那个无法一眼看出结果的式子，我们就可以采用刚刚例三的思路.</li>
<li>先考虑将那些特殊性质不明显的数弄掉，再尝试猜积性函数。当然不一定一试就中，但是只要我们有足够的耐心与信念，相信这个题目所给的一定能筛，就一定能试出来233.</li>
<li>当然还有一种方法，从常见的完全积性函数开始试，如果都不行，在尝试一下高次的完全积性函数，之后尝试非完全积性函数（虽说一般都不是这个。。。），如果还是不行，那就算了吧，（反正就那一点分么。。。），试不出，技不如人，甘拜下风233.</li>
</ul>
<hr />
<h2 id="题目">题目</h2>
<ul>
<li>题目可以去51nod上找，那上面杜教筛的题目挺多的，我就不粘地址啦！</li>
<li>洛谷上也有模板题！</li>
<li>当然，洛谷上也有需要推式子的题目，我以后有时间再加吧！</li>
</ul>
</div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


</div>
